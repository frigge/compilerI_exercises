%header {:
 // this code is inlined before the generated parser
package minijava;
:};

%terminals kw_class,  kw_public, kw_static, kw_void, kw_while, kw_if, kw_else, kw_extends, kw_return, kw_System_out_println, kw_this, kw_new, kw_main,
                t_String, t_int, t_boolean,
                sym_open, sym_open_square, sym_open_curly, sym_close, sym_close_square, sym_close_curly, sym_semicolon, sym_comma, sym_equals, sym_dot_len, sym_dot, 
                sym_exclam, sym_logic_and, sym_plus, sym_minus, sym_mult, sym_less,
                c_true, c_false,
                integer_lit,
                ident;

%typeof Program 		= "Program";
%typeof op 				= "Op";
%typeof id 				= "Id";
%typeof ExpRest 		= "Exp";
%typeof ExpRestList		= "List<Exp>";
%typeof ExpList			= "List<Exp>";
%typeof Exp 			= "Exp";
%typeof StatementList 	= "List<Statement>";
%typeof Statement 		= "Statement";
%typeof Type 			= "Type";
%typeof ParamList 		= "List<Param>";
%typeof ParamRestList 	= "List<Param>";
%typeof ParamRest 		= "Param";
%typeof MethodDeclList 	= "List<MethodDecl>";
%typeof MethodDecl 		= "MethodDecl";
%typeof VarDeclList 	= "List<VarDecl>";
%typeof VarDecl 		= "VarDecl";
%typeof ClassDecl 		= "ClassDecl";
%typeof ClassDeclList 	= "List<ClassDecl>";
%typeof MainClass 		= "MainClass";

%goal Program;

// Productions with semantic actions building the JastAdd AST

Program = MainClass.m ClassDeclList.cls                                                 {: return new Program(m, cls); :};

MainClass = kw_class id.cName sym_open_curly kw_public kw_static kw_void kw_main sym_open t_String sym_open_square sym_close_square id.params sym_close sym_open_curly VarDeclList.vars StatementList.statements sym_close_curly sym_close_curly
																						{: return new MainClass(cName, params, vars, statements); :};

ClassDeclList = ClassDecl.c ClassDeclList.l                                             {: l.add(c); return l; :}
        |                                                                               {: return new List<ClassDecl>(); :};

ClassDecl = kw_class id.i sym_open_curly VarDeclList.vdl MethodDeclList.mdl sym_close_curly                 {: return new ClassDecl(i, new Opt<Id>(), vdl, mdl); :}
		| kw_class id.i kw_extends id.e sym_open_curly VarDeclList.vdl MethodDeclList.mdl sym_close_curly   {: return new ClassDecl(i, new Opt<Id>(e), vdl, mdl); :};

VarDeclList = VarDecl.v VarDeclList.l                                                   {: l.add(v); return l; :}
        |                                                                               {: return new List<VarDecl>(); :};
VarDecl = Type.t id.i sym_semicolon														{: return new VarDecl(t,i); :};

MethodDeclList = MethodDecl.m MethodDeclList.l                                          {: l.add(m); return l; :}
        |                                                                               {: return new List<MethodDecl>(); :};
MethodDecl = kw_public Type.returnType id.methodName sym_open ParamList.params sym_close sym_open_curly VarDeclList.vars StatementList.statements kw_return Exp.ret sym_semicolon sym_close_curly
																						{: return new MethodDecl(returnType, methodName, params, vars, statements, ret); :}
		| kw_public Type.returnType id.methodName sym_open sym_close sym_open_curly VarDeclList.vars StatementList.statements kw_return Exp.ret sym_semicolon sym_close_curly
																						{: return new MethodDecl(returnType, methodName, new List<Param>(), vars, statements, ret); :};

ParamList = Type.t id.i ParamRestList.l													{: Param p = new Param(t,i); l.add(p); return l; :};
ParamRestList = ParamRest.p ParamRestList.l												{: l.add(p); return l; :}
		|																				{: return new List<Param>(); :};
ParamRest = sym_comma Type.t id.i														{: return new Param(t,i); :};

Type = t_int sym_open_square sym_close_square 											{: return new IntArrType(); :}
		| t_boolean																		{: return new BooleanType(); :} 
		| t_int 																		{: return new IntType(); :}
		| id.i																			{: return new IdType(i); :};

StatementList = StatementList.l Statement.s                                             {: l.add(s); return(l); :}
        |                                                                               {: return new List<Statement>(); :};
Statement = sym_open_curly StatementList.l sym_close_curly 								{: return new StmList(l); :}
        | kw_if sym_open Exp.i sym_close Statement.t kw_else Statement.e				{: return new IfThenElse(i,t,e); :}
        | kw_while sym_open Exp.b sym_close Statement.s									{: return new While(b,s); :}
        | kw_System_out_println sym_open Exp.e sym_close sym_semicolon					{: return new Syso(e); :}
        | id.feld sym_equals Exp.value sym_semicolon									{: return new Zuweisung(feld,value); :}
        | id.feld sym_open_square Exp.pos sym_close_square sym_equals Exp.value sym_semicolon
        																				{:return new ArrZuw(feld,pos,value); :};

Exp = Exp.l op.o Exp.r																	{: return new BinOpExp(l,o,r); :}
        | Exp.f sym_open_square Exp.p sym_close_square									{: return new ArrayExp(f,p); :}
        | Exp.f sym_dot_len																{: return new LengthExp(f); :}
        | Exp.f sym_dot id.m sym_open ExpList.p sym_close								{: return new MethodExp(f,m,p); :}
        | Exp.f sym_dot id.m sym_open sym_close											{: return new MethodExp(f,m, new List<Exp>()); :}
        | c_true																		{: return new TrueExp(); :}
        | c_false																		{: return new FalseExp(); :}
        | id.i																			{: return new IdExp(i); :}
        | integer_lit.i																	{: return new IntLit(i.value.toString()); :}
        | kw_this																		{: return new ThisExp(); :}
        | kw_new t_int sym_open_square Exp.g sym_close_square							{: return new IntArrExp(g); :}
        | kw_new id.k sym_open sym_close												{: return new NewExp(k); :}
        | sym_exclam Exp.e																{: return new NotExp(e); :}
        | sym_open Exp.e sym_close														{: return new Geklammert(e); :};
        
ExpList = Exp.e ExpRestList.l															{: List<Exp> l2 = new List<Exp>(); l2.add(e); for(Exp v: l){l2.add(v);}; return l2; :};
ExpRestList = ExpRestList.l ExpRest.r													{: l.add(r); return l; :}
		|																				{: return new List<Exp>(); :};
ExpRest = sym_comma Exp.e																{: return e; :};

id = ident.i																			{: return new Id(i.value.toString()); :};

op = sym_logic_and																		{: return new And(); :}
        | sym_plus																		{: return new Plus(); :}
        | sym_minus																		{: return new Minus(); :}
        | sym_mult																		{: return new Mul(); :}
        | sym_less																		{: return new Less(); :};